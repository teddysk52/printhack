<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PRINTHACK | TEAM KIK</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000000;
      color: #ffffff;
      overflow-x: hidden;
      position: relative;
      min-height: 100vh;
    }

    /* Звездное небо */
    body::before,
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    body::before {
      background-image: 
        radial-gradient(1px 1px at 10% 20%, white, transparent),
        radial-gradient(1px 1px at 20% 40%, white, transparent),
        radial-gradient(1px 1px at 30% 10%, white, transparent),
        radial-gradient(1px 1px at 40% 60%, white, transparent),
        radial-gradient(1px 1px at 50% 30%, white, transparent),
        radial-gradient(1px 1px at 60% 70%, white, transparent),
        radial-gradient(1px 1px at 70% 15%, white, transparent),
        radial-gradient(1px 1px at 80% 50%, white, transparent),
        radial-gradient(1px 1px at 90% 80%, white, transparent),
        radial-gradient(1px 1px at 15% 85%, white, transparent),
        radial-gradient(1px 1px at 25% 65%, white, transparent),
        radial-gradient(1px 1px at 35% 45%, white, transparent),
        radial-gradient(1px 1px at 45% 25%, white, transparent),
        radial-gradient(1px 1px at 55% 75%, white, transparent),
        radial-gradient(1px 1px at 65% 35%, white, transparent),
        radial-gradient(1px 1px at 75% 90%, white, transparent),
        radial-gradient(1px 1px at 85% 10%, white, transparent),
        radial-gradient(1px 1px at 95% 55%, white, transparent);
      animation: twinkle 5s infinite alternate;
    }

    body::after {
      background-image: 
        radial-gradient(1px 1px at 12% 18%, white, transparent),
        radial-gradient(1px 1px at 22% 38%, white, transparent),
        radial-gradient(1px 1px at 32% 68%, white, transparent),
        radial-gradient(1px 1px at 42% 28%, white, transparent),
        radial-gradient(1px 1px at 52% 78%, white, transparent),
        radial-gradient(1px 1px at 62% 48%, white, transparent),
        radial-gradient(1px 1px at 72% 88%, white, transparent),
        radial-gradient(1px 1px at 82% 8%, white, transparent),
        radial-gradient(1px 1px at 92% 58%, white, transparent);
      animation: twinkle 5s infinite alternate-reverse;
    }

    @keyframes twinkle {
      0% { opacity: 0.6; }
      100% { opacity: 1; }
    }

    .container {
      position: relative;
      z-index: 1;
    }

    /* Header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 1.5rem 3rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      backdrop-filter: blur(10px);
      background: rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 800;
      letter-spacing: -0.5px;
    }

    .header-buttons {
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-glass {
      background: rgba(255, 255, 255, 0.05);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }

    .btn-glass:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
    }

    .btn-primary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-primary:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(255, 255, 255, 0.15);
    }

    /* Hero Section */
    .hero {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6rem 2rem 2rem;
    }

    #canvas-container {
      width: 100%;
      max-width: 900px;
      height: 700px;
      position: relative;
      cursor: grab;
      flex: 1;
    }

    #canvas-container.grabbing {
      cursor: grabbing;
    }

    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }

    .viewer-wrapper {
      position: relative;
      width: 100%;
      max-width: 1200px;
      display: flex;
      gap: 2rem;
      align-items: center;
      justify-content: center;
      margin-top: 2rem;
    }

    .side-controls {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      min-width: 180px;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .control-section-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .control-btn {
      padding: 1rem 1.4rem;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.7rem;
      font-size: 1rem;
      white-space: nowrap;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(255, 255, 255, 0.15);
    }

    .control-btn.active {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .control-btn svg {
      width: 22px;
      height: 22px;
    }

    .zoom-info {
      text-align: center;
      font-size: 0.75rem;
      opacity: 0.6;
      margin-top: 0.25rem;
    }

    .hint-text {
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.5;
      margin-top: 1rem;
      font-style: italic;
    }

    /* Color Preview Section */
    .color-preview {
      max-width: 1200px;
      margin: 4rem auto;
      padding: 0 2rem;
      text-align: center;
    }

    .color-preview h2 {
      font-size: 1.8rem;
      font-weight: 700;
      margin-bottom: 1rem;
      letter-spacing: -0.5px;
    }

    .color-preview p {
      font-size: 1rem;
      opacity: 0.7;
      margin-bottom: 2rem;
    }

    .preview-image {
      max-width: 800px;
      width: 100%;
      margin: 0 auto;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .preview-image img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Footer */
    .footer {
      padding: 3rem 2rem 2rem;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 4rem;
    }

    .footer-content {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .footer-team {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .footer-team h3 {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .team-members {
      display: flex;
      gap: 1rem;
      justify-content: center;
      align-items: center;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .team-members span {
      opacity: 0.5;
    }

    .footer-school {
      font-size: 0.95rem;
      opacity: 0.7;
      font-weight: 500;
    }

    .footer-copyright {
      font-size: 0.85rem;
      opacity: 0.5;
      margin-top: 1rem;
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem 1.5rem;
      }

      .logo {
        font-size: 1.2rem;
      }

      .header-buttons {
        gap: 0.5rem;
      }

      .btn {
        padding: 0.6rem 1rem;
        font-size: 0.85rem;
      }

      #canvas-container {
        height: 400px;
      }

      .controls {
        gap: 0.5rem;
      }

      .control-btn {
        padding: 0.75rem 1.25rem;
        font-size: 0.85rem;
      }

      .side-controls {
        order: -1;
        flex-direction: row;
        min-width: auto;
        width: 100%;
        justify-content: center;
      }

      .control-section {
        flex: 1;
        min-width: 140px;
      }

      .viewer-wrapper {
        flex-direction: column;
      }

      .hint-text {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="logo">PRINTHACK | TEAM KIK</div>
      <div class="header-buttons">
        <button class="btn btn-glass" onclick="downloadCAD()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          Stáhnout CAD
        </button>
        <button class="btn btn-primary" onclick="openDocs()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
            <line x1="16" y1="13" x2="8" y2="13"/>
            <line x1="16" y1="17" x2="8" y2="17"/>
            <polyline points="10 9 9 9 8 9"/>
          </svg>
          Dokumentace
        </button>
      </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
      <div class="viewer-wrapper">
        <div class="side-controls">
          <!-- Zoom Section -->
          <div class="control-section">
            <div class="control-section-title">Přiblížení</div>
            <button class="control-btn" onclick="zoomIn()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="M21 21l-4.35-4.35"/>
                <line x1="11" y1="8" x2="11" y2="14"/>
                <line x1="8" y1="11" x2="14" y2="11"/>
              </svg>
              Přiblížit
            </button>
            <button class="control-btn" onclick="zoomOut()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="M21 21l-4.35-4.35"/>
                <line x1="8" y1="11" x2="14" y2="11"/>
              </svg>
              Oddálit
            </button>
            <div class="zoom-info" id="zoomInfo">100%</div>
          </div>

          <!-- View Section -->
          <div class="control-section">
            <div class="control-section-title">Zobrazení</div>
            <button class="control-btn" onclick="resetView()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                <polyline points="9 22 9 12 15 12 15 22"/>
              </svg>
              Resetovat
            </button>
            <button class="control-btn" id="rotateBtn" onclick="toggleRotation()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
              </svg>
              <span id="rotateText">Otáčet</span>
            </button>
          </div>
        </div>

        <div id="canvas-container"></div>
      </div>
    </section>

    <!-- Color Preview Section -->
    <section class="color-preview">
      <h2>Barevná verze modelu</h2>
      <p>Tak vypadá model v plných barvách z designu</p>
      <div class="preview-image">
        <img src="trophy.PNG" alt="Colored Trophy Model">
      </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
      <div class="footer-content">
        <div class="footer-team">
          <h3>TEAM KIK</h3>
          <div class="team-members">
            <div>Kamil</div>
            <span>•</span>
            <div>Ivan</div>
            <span>•</span>
            <div>Kristýna</div>
          </div>
        </div>
        <div class="footer-school">
          INFIS — Střední škola informatiky a finančních služeb
        </div>
        <div class="footer-copyright">
          © 2025 PRINTHACK. All rights reserved.
        </div>
      </div>
    </footer>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Three.js Scene Setup
    let scene, camera, renderer, trophy, controls, autoRotate = false;
    let currentZoom = 5;

    function init() {
      const container = document.getElementById('canvas-container');
      
      // Scene
      scene = new THREE.Scene();
      
      // Camera
      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 3, 8);
      camera.lookAt(0, 2, 0);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true 
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(5, 8, 5);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 2048;
      keyLight.shadow.mapSize.height = 2048;
      keyLight.shadow.camera.near = 0.5;
      keyLight.shadow.camera.far = 50;
      scene.add(keyLight);
      
      const fillLight = new THREE.PointLight(0xFFD700, 0.6);
      fillLight.position.set(-5, 3, -5);
      scene.add(fillLight);
      
      const rimLight = new THREE.PointLight(0xffffff, 0.4);
      rimLight.position.set(0, -5, 5);
      scene.add(rimLight);
      
      // OrbitControls для удобного управления
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 3;
      controls.maxDistance = 15;
      controls.target.set(0, 2, 0);
      controls.update();
      
      // Load Trophy from OBJ file
      loadTrophy();
      
      // Handle resize
      window.addEventListener('resize', onWindowResize);
      
      // Animation loop
      animate();
    }

    function loadTrophy() {
      const loader = new THREE.OBJLoader();
      
      loader.load(
        'Full.obj',
        function (object) {
          // Создаем группу для модели
          trophy = new THREE.Group();
          
          // Применяем улучшенный рендеринг ко всем мешам, сохраняя оригинальные цвета
          object.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
              // Если у меша уже есть материал с цветом, улучшаем его
              if (child.material) {
                // Создаем новый материал на основе существующего цвета
                const originalColor = child.material.color || new THREE.Color(0xcccccc);
                child.material = new THREE.MeshStandardMaterial({
                  color: originalColor,
                  metalness: 0.3,
                  roughness: 0.4,
                  envMapIntensity: 0.5
                });
              } else {
                // Если материала нет, создаем базовый
                child.material = new THREE.MeshStandardMaterial({
                  color: 0xcccccc,
                  metalness: 0.3,
                  roughness: 0.4,
                  envMapIntensity: 0.5
                });
              }
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          // Центрируем модель
          const box = new THREE.Box3().setFromObject(object);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          // Масштабируем модель чтобы она была подходящего размера
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 4 / maxDim; // Масштаб чтобы модель была примерно 4 единицы в высоту
          object.scale.multiplyScalar(scale);
          
          // Центрируем по X и Z, ставим на землю по Y
          object.position.x = -center.x * scale;
          object.position.z = -center.z * scale;
          object.position.y = -box.min.y * scale;
          
          trophy.add(object);
          
          // Ground shadow plane
          const shadowPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.ShadowMaterial({ opacity: 0.3 })
          );
          shadowPlane.rotation.x = -Math.PI / 2;
          shadowPlane.position.y = -0.01;
          shadowPlane.receiveShadow = true;
          scene.add(shadowPlane);
          
          // Добавляем трофей в сцену
          scene.add(trophy);
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },
        function (error) {
          console.error('An error happened loading the model:', error);
          alert('Ошибка загрузки модели. Проверьте консоль.');
        }
      );
    }

    function createTrophy() {
      trophy = new THREE.Group();
      
      // Materials
      const goldMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFD700,
        metalness: 0.95,
        roughness: 0.15,
        envMapIntensity: 1
      });
      
      const bronzeMaterial = new THREE.MeshStandardMaterial({
        color: 0xCD7F32,
        metalness: 0.9,
        roughness: 0.2,
        envMapIntensity: 0.8
      });
      
      const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.9,
        transparent: true,
        opacity: 0.8,
        thickness: 0.5
      });
      
      // Base - wider and more stable
      const base = new THREE.Mesh(
        new THREE.CylinderGeometry(1.2, 1.5, 0.3, 32),
        bronzeMaterial
      );
      base.position.y = 0;
      base.castShadow = true;
      base.receiveShadow = true;
      trophy.add(base);
      
      // Base detail ring
      const baseRing = new THREE.Mesh(
        new THREE.TorusGeometry(1.35, 0.05, 16, 32),
        goldMaterial
      );
      baseRing.position.y = 0.15;
      baseRing.rotation.x = Math.PI / 2;
      baseRing.castShadow = true;
      trophy.add(baseRing);
      
      // Middle base
      const middleBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.8, 1.2, 0.3, 32),
        goldMaterial
      );
      middleBase.position.y = 0.3;
      middleBase.castShadow = true;
      middleBase.receiveShadow = true;
      trophy.add(middleBase);
      
      // Decorative band
      const band = new THREE.Mesh(
        new THREE.CylinderGeometry(0.85, 0.85, 0.15, 32),
        bronzeMaterial
      );
      band.position.y = 0.5;
      band.castShadow = true;
      trophy.add(band);
      
      // Stem
      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.8, 1, 32),
        goldMaterial
      );
      stem.position.y = 0.9;
      stem.castShadow = true;
      stem.receiveShadow = true;
      trophy.add(stem);
      
      // Stem top ring
      const stemRing = new THREE.Mesh(
        new THREE.TorusGeometry(0.6, 0.08, 16, 32),
        bronzeMaterial
      );
      stemRing.position.y = 1.4;
      stemRing.rotation.x = Math.PI / 2;
      stemRing.castShadow = true;
      trophy.add(stemRing);
      
      // Cup transition
      const cupBase = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 0.7, 0.4, 32),
        goldMaterial
      );
      cupBase.position.y = 1.6;
      cupBase.castShadow = true;
      cupBase.receiveShadow = true;
      trophy.add(cupBase);
      
      // Main cup
      const cup = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 1, 2.5, 32),
        goldMaterial
      );
      cup.position.y = 2.8;
      cup.castShadow = true;
      cup.receiveShadow = true;
      trophy.add(cup);
      
      // Inner cup detail
      const innerCup = new THREE.Mesh(
        new THREE.CylinderGeometry(1.4, 0.95, 2.4, 32),
        new THREE.MeshStandardMaterial({
          color: 0xB8860B,
          metalness: 0.9,
          roughness: 0.3
        })
      );
      innerCup.position.y = 2.75;
      trophy.add(innerCup);
      
      // Cup rim
      const rim = new THREE.Mesh(
        new THREE.TorusGeometry(1.5, 0.12, 16, 32),
        bronzeMaterial
      );
      rim.position.y = 4.05;
      rim.rotation.x = Math.PI / 2;
      rim.castShadow = true;
      trophy.add(rim);
      
      // Outer decorative rim
      const outerRim = new THREE.Mesh(
        new THREE.TorusGeometry(1.6, 0.06, 16, 32),
        goldMaterial
      );
      outerRim.position.y = 4.05;
      outerRim.rotation.x = Math.PI / 2;
      outerRim.castShadow = true;
      trophy.add(outerRim);
      
      // Left handle
      const handleLeft = new THREE.Mesh(
        new THREE.TorusGeometry(0.5, 0.15, 16, 32, Math.PI),
        goldMaterial
      );
      handleLeft.position.set(-1.8, 2.8, 0);
      handleLeft.rotation.z = -Math.PI / 2;
      handleLeft.castShadow = true;
      trophy.add(handleLeft);
      
      // Left handle ornament
      const handleLeftOrn = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        glassMaterial
      );
      handleLeftOrn.position.set(-1.8, 3.3, 0);
      handleLeftOrn.castShadow = true;
      trophy.add(handleLeftOrn);
      
      // Right handle
      const handleRight = new THREE.Mesh(
        new THREE.TorusGeometry(0.5, 0.15, 16, 32, Math.PI),
        goldMaterial
      );
      handleRight.position.set(1.8, 2.8, 0);
      handleRight.rotation.z = Math.PI / 2;
      handleRight.castShadow = true;
      trophy.add(handleRight);
      
      // Right handle ornament
      const handleRightOrn = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        glassMaterial
      );
      handleRightOrn.position.set(1.8, 3.3, 0);
      handleRightOrn.castShadow = true;
      trophy.add(handleRightOrn);
      
      // Decorative elements around cup
      const decoCount = 12;
      for (let i = 0; i < decoCount; i++) {
        const angle = (i / decoCount) * Math.PI * 2;
        const radius = 1.3;
        
        const deco = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.5, 0.12),
          bronzeMaterial
        );
        deco.position.set(
          Math.cos(angle) * radius,
          2.8,
          Math.sin(angle) * radius
        );
        deco.rotation.y = angle;
        deco.castShadow = true;
        trophy.add(deco);
      }
      
      // Mid cup ring detail
      const midRing = new THREE.Mesh(
        new THREE.TorusGeometry(1.25, 0.08, 16, 32),
        bronzeMaterial
      );
      midRing.position.y = 2.2;
      midRing.rotation.x = Math.PI / 2;
      midRing.castShadow = true;
      trophy.add(midRing);
      
      // Top star assembly
      const starGroup = new THREE.Group();
      starGroup.position.y = 4.3;
      
      // Star base
      const starBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.4, 0.2, 6),
        bronzeMaterial
      );
      starBase.castShadow = true;
      starGroup.add(starBase);
      
      // Center sphere
      const centerSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 32, 32),
        goldMaterial
      );
      centerSphere.position.y = 0.2;
      centerSphere.castShadow = true;
      starGroup.add(centerSphere);
      
      // Star rays (5-pointed)
      const rayCount = 5;
      for (let i = 0; i < rayCount; i++) {
        const angle = (i / rayCount) * Math.PI * 2 - Math.PI / 2;
        
        const ray = new THREE.Mesh(
          new THREE.ConeGeometry(0.18, 0.7, 4),
          goldMaterial
        );
        ray.position.set(
          Math.cos(angle) * 0.5,
          0.25,
          Math.sin(angle) * 0.5
        );
        ray.rotation.y = angle;
        ray.rotation.z = -Math.PI / 2;
        ray.castShadow = true;
        starGroup.add(ray);
      }
      
      // Top crystal
      const crystal = new THREE.Mesh(
        new THREE.OctahedronGeometry(0.3, 0),
        glassMaterial
      );
      crystal.position.y = 0.65;
      crystal.castShadow = true;
      starGroup.add(crystal);
      
      // Small accent lights on crystal
      const crystalLight = new THREE.PointLight(0xffffff, 0.3, 2);
      crystalLight.position.y = 0.65;
      starGroup.add(crystalLight);
      
      trophy.add(starGroup);
      
      // Ground shadow plane
      const shadowPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 10),
        new THREE.ShadowMaterial({ opacity: 0.3 })
      );
      shadowPlane.rotation.x = -Math.PI / 2;
      shadowPlane.position.y = -0.01;
      shadowPlane.receiveShadow = true;
      scene.add(shadowPlane);
      
      // Position trophy
      trophy.position.y = 0;
      scene.add(trophy);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Update controls
      if (controls) {
        controls.update();
      }
      
      // Auto rotate
      if (autoRotate && controls) {
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2.0;
      } else if (controls) {
        controls.autoRotate = false;
      }
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Controls
    function toggleRotation() {
      autoRotate = !autoRotate;
      const btn = document.getElementById('rotateBtn');
      const text = document.getElementById('rotateText');
      if (autoRotate) {
        btn.classList.add('active');
        text.textContent = 'Zastavit';
      } else {
        btn.classList.remove('active');
        text.textContent = 'Otáčet';
      }
    }

    function zoomIn() {
      if (controls) {
        const distance = camera.position.distanceTo(controls.target);
        const newDistance = Math.max(3, distance - 0.8);
        const direction = camera.position.clone().sub(controls.target).normalize();
        camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
        updateZoomInfo();
      }
    }

    function zoomOut() {
      if (controls) {
        const distance = camera.position.distanceTo(controls.target);
        const newDistance = Math.min(15, distance + 0.8);
        const direction = camera.position.clone().sub(controls.target).normalize();
        camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
        updateZoomInfo();
      }
    }

    function resetView() {
      if (controls) {
        camera.position.set(0, 3, 8);
        controls.target.set(0, 2, 0);
        controls.update();
        updateZoomInfo();
      }
      
      if (autoRotate) {
        toggleRotation();
      }
    }

    function updateZoomInfo() {
      if (controls) {
        const distance = camera.position.distanceTo(controls.target);
        const zoomPercent = Math.round(((15 - distance) / 12) * 100);
        document.getElementById('zoomInfo').textContent = zoomPercent + '%';
      }
    }

    function downloadCAD() {
      // Скачивание OBJ файла
      const link = document.createElement('a');
      link.href = 'Full.obj';
      link.download = 'Trophy_Model.obj';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function openDocs() {
      alert('Dokumentace bude brzy!\n\nDokumentace je ve vývoji.');
    }

    // Initialize
    init();
    updateZoomInfo();
  </script>
</body>
</html>
